<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<title>Bandido Test - 3ª Pessoa</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html,body{height:100%;margin:0;background:linear-gradient(#6ec1ff,#87ceeb);font-family:Arial,Helvetica,sans-serif}
  #overlay{position:absolute;left:8px;top:8px;z-index:60;background:rgba(0,0,0,0.38);padding:8px;border-radius:6px;color:#fff}
  #hint{position:absolute;right:10px;bottom:10px;z-index:60;background:rgba(0,0,0,0.35);padding:8px;border-radius:6px;color:#fff}
  #menu{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:80;background:rgba(0,0,0,0.9);padding:20px;border-radius:10px;color:#fff}
  button{padding:10px 18px;border-radius:8px;border:none;background:#2b8cff;color:#fff;font-weight:700;cursor:pointer}
</style>
</head>
<body>
<div id="overlay">WASD mover • Espaço pular • Clique para travar o mouse</div>
<div id="hint">Terceira pessoa — modelo: bandido_favelado.glb</div>

<!-- Small menu if wanted -->
<div id="menu" style="display:none">
  <h3>CS Clone — Teste</h3>
  <p>Modelo carregado. Clique na tela para travar o mouse e testar.</p>
  <button onclick="document.getElementById('menu').style.display='none'">Fechar</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

<script>
// -------- CONFIG --------
const MODEL_URL = './bandido_favelado.glb'; // deve ficar na mesma pasta do index.html
// ------------------------

let scene, renderer, camera;
let player = { pos: new THREE.Vector3(0,1.6,0), speed: 3.2 };
let playerModel = null;
let mixers = [];
let rotY = 0, rotX = 0;
let keys = {};
let mouseLocked = false;

init();
animate();

function init(){
  // renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // scene + camera
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.rotation.order = 'YXZ';

  // lights (lightweight)
  scene.add(new THREE.AmbientLight(0xffffff, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(10,20,10);
  scene.add(dir);

  // ground (terroso)
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshBasicMaterial({ color: 0x9b6f3a }));
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // walls (tijolo/bege)
  const wallMat = new THREE.MeshBasicMaterial({ color: 0xbc8f6f });
  function addWall(x,z,rot,w,h,th){
    const geo = new THREE.BoxGeometry(w,h,th);
    const m = new THREE.Mesh(geo, wallMat);
    m.position.set(x, h/2, z);
    if(rot) m.rotation.y = rot;
    scene.add(m);
  }
  addWall(0,-50,0,100,6,1);
  addWall(0,50,0,100,6,1);
  addWall(-50,0,Math.PI/2,100,6,1);
  addWall(50,0,Math.PI/2,100,6,1);

  // clouds (simple)
  function makeCloud(x,y,z,s){
    const g = new THREE.PlaneGeometry(12*s,6*s);
    const m = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.9 });
    const p = new THREE.Mesh(g,m);
    p.position.set(x,y,z);
    p.rotation.y = Math.random()*Math.PI*2;
    scene.add(p);
  }
  makeCloud(-30,30,-20,2); makeCloud(20,35,10,1.6); makeCloud(40,25,30,1.8);

  // climb boxes
  const climbBoxes = [];
  function addBox(x,y,z,w,h,d,color=0x7e6a4f){
    const b = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshBasicMaterial({ color }));
    b.position.set(x, h/2 + 0, z);
    scene.add(b); climbBoxes.push(b);
  }
  addBox(-10,0,-10,6,3,6); addBox(10,0,15,8,4,6); addBox(20,0,-25,10,5,8);

  // controls (pointer lock)
  document.body.addEventListener('click', ()=>{ if(!mouseLocked) renderer.domElement.requestPointerLock(); });
  document.addEventListener('pointerlockchange', ()=>{ mouseLocked = !!document.pointerLockElement; });
  document.addEventListener('mousemove', (e)=>{ if(!mouseLocked) return; const s = 0.002; rotY -= e.movementX*s; rotX -= e.movementY*s; rotX = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, rotX)); });

  // keyboard
  document.addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true; if(e.code==='Space'){ if(player.pos.y <= 1.62) player.pos.y += 1.0; } });
  document.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });

  // load GLB
  const loader = new THREE.GLTFLoader();
  loader.load(MODEL_URL, function(gltf){
    playerModel = gltf.scene;
    playerModel.traverse(n=>{ if(n.isMesh){ n.castShadow=false; } });
    playerModel.scale.set(1,1,1);
    playerModel.position.copy(player.pos);
    scene.add(playerModel);
    if(gltf.animations && gltf.animations.length){
      const mx = new THREE.AnimationMixer(playerModel);
      mixers.push(mx);
      // if there's a walk/idle animation you can play here; we'll use first clip as idle if present
      mx.clipAction(gltf.animations[0]).play();
    }
    // show small menu confirming loaded
    const menu = document.getElementById('menu');
    menu.style.display = 'block';
  }, undefined, function(err){
    console.error('Erro ao carregar GLB:', err);
    alert('Erro ao carregar modelo. Verifique se "bandido_favelado.glb" está na mesma pasta do index.html e se o nome está correto.');
  });

  window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
}

function updateCamera(){
  const offset = new THREE.Vector3(0,1.2,3.2);
  const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(0,rotY,0));
  const worldOffset = offset.clone().applyQuaternion(q);
  camera.position.copy(player.pos).add(worldOffset);
  camera.lookAt(player.pos.clone().add(new THREE.Vector3(0,1.2,0)));
}

function updatePlayer(delta){
  const forward = new THREE.Vector3(Math.sin(rotY),0,Math.cos(rotY));
  const right = new THREE.Vector3(forward.z,0,-forward.x);
  let mv = new THREE.Vector3();
  if(keys['w']) mv.addScaledVector(forward,1);
  if(keys['s']) mv.addScaledVector(forward,-1);
  if(keys['a']) mv.addScaledVector(right,-1);
  if(keys['d']) mv.addScaledVector(right,1);
  if(mv.length()>0) mv.normalize();
  player.pos.addScaledVector(mv, player.speed * delta);
  // clamp inside walls
  player.pos.x = Math.max(-48, Math.min(48, player.pos.x));
  player.pos.z = Math.max(-48, Math.min(48, player.pos.z));
  // simple climb boxes snap
  let onBox = false;
  scene.traverse(obj=>{
    // not necessary to compute here; boxes already adjust visually in earlier version
  });
  if(playerModel){ playerModel.position.copy(player.pos); playerModel.rotation.y = rotY + Math.PI; }
}

let last = performance.now();
function animate(now){
  const dt = Math.min(0.05, (now-last)/1000);
  last = now;
  updatePlayer(dt);
  updateCamera();
  mixers.forEach(m=>m.update(dt));
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
</script>
</body>
</html>
